
一、定义基本表
CREATE TABLE <表名>(<列名><数据类型> [列级完整性约束条件] 
[，<列名> <数据类型> [列级完整性约束条件] 
[,<表级完整性约束条件>])； 

其中<表名>是所要定义的基本表的名字，它可以由一个或多个属性(列)组成。<列名>是所要定义的列的名字，完整性约束条件表示表中数据需要满足的约束条件。

二、修改基本表
ALTER TABLE <表名>
[ADD <新列名><数据类型>[完s整性约束]]
[ DROP column 列名]
[add constraint <完整性约束名> <完整性约束>]
[DROP constraint <完整性约束名>]
[MODIFY<列名> <数据类型>[完整性约束]]
]; 　
其中<表名>指定需要修改的基本表，
ADD子句用于增加新列和新的完整性约束条件，
DROP子句用于删除指定的完整性约束条件，
MODIFY子句用于修改原有的列定义。

三、 建立索引与删除
建立：
	要想创建一个索引，首先需要一个表。在CREATE INDEX语句中，告诉数据库创建的新索引的名称是什么，要在哪个表上建立索引，以及包含哪些列。 
一般格式为：
	CREATE [UNIQUE] [CLUSTER] INDEX <索引名>  
	ON <表名> (<列名>[<次序>][,<列名>[<次序>]]...); 
	其中，<表名>指定要建索引的基本表的名字。索引可以建在该表的一列或多列上，各列名之间用逗号分隔。每个<列名>后面还可以用<次序>指定索引值的排列次序，包括ASC(升序)和DESC(降序)两种，缺省值为ASC
UNIQUE表明此索引的每一个索引值只对应唯一的数据记录。 
CLUSTER表示要建立的索引是聚簇索引。所谓聚簇索引是指索引项的顺序与表中记录的物理顺序一致的索引组织，聚簇索引在Oracle中只能在定义表的同时定义。用户可以在最常查询的列上建立聚簇索引以提高查询效率。在一个基本表上最多只能建立一个聚簇索引。建立聚簇索引后，更新索引列数据时，往往导致表中记录的物理顺序的变更，代价较大，因此对于经常更新的列不宜建立聚簇索引。
在Oracle中，对一个表中的主键的字段不能建立唯一索引，因为创建主键约束时，系统已经自动生成一个唯一索引。

删除索引：
	DROP INDEX<索引名>;
索引一经建立，就由系统使用和维护它，不需用户干预。
建立索引是为了减少查询操作的时间，但如果数据增删改频繁，系统会花费许多时间来维护索引。

四、 数据查询
1. 语句格式
       SELECT [ALL|DISTINCT] <目标列表达式>
                             [，<目标列表达式>] …
FROM <表名或视图名>[， <表名或视图名> ] …
[ WHERE <条件表达式> ]
[ GROUP BY <列名1> [ HAVING <条件表达式> ] ]
[ ORDER BY <列名2> [ ASC|DESC ] ]；

2. SELECT子句的<目标列表达式>可以为：
	1. 算术表达式
	2. 字符串常量
	3. 函数
	4. 列别名 

3. 指定列别名：
	对于查出来的列有时列名不能清晰表达列的含义，或显示的是列的表达式。这些情况用户可以在列的后面(用空格分开)指定相应列的别名，如果别名中含有空格，则用双引号进行包含。 
	例如： SELECT Sname, 2009-Sage  “Stu birthday”
		   FROM Student;
4. distinct关键字：
	DISTINCT 关键字可从SELECT语句的结果中除去重复的行。如果没有指定DISTINCT,则默认为ALL，那么将返回所有行，包括重复的行。

5. where子句：
	WHERE子句后面跟的是条件的布尔组合，其结果是查询指定条件的元组。WHERE子句常用的查询条件如表所示。 

	比较		=，>，<，>=，<=，!=，<>，!>，!<；NOT+上述比较运算符
	确定范围		BETWEEN AND，NOT BETWEEN AND
	确定集合		IN, NOT IN
	字符匹配		LIKE, NOTLIKE
	空值			IS NULL, IS NOT NULL
	多重条件（逻辑运算）	AND, OR, NOT

	（1）BETWEEN AND：
		BETWEEN  AND操作符可以选中排列于两值(包括这两个值)之间的数据。这些数据可以是数字，文字或是日期。也就是说，通过BETWEEN  AND确定一个范围，并且把这个范围内的数据库中的值输出。

		例如：
		SELECT Sname, Sage
		FROM Student 
		WHERE Sage BETWEEN 20 AND 23; 

	（2）IN 与 NOT IN：
		当用户知道某列的准确值并想要返回其记录，则可以使用IN操作符。IN指令可以让用户在一个或数个不连续的值的限制之内取出表中的值。	IN与NOT IN相反.

		例如：
		SELECT Sname, Sage 　
		FROM Student 　
		WHERE Sage IN (18,20);

	（3）LIKE字符匹配
		语法格式：
			[NOT] LIKE '<模式>' [ESCAPE '<换码字符>']

			其含义是查找指定的属性列值与<模式>相匹配的元组。模式可以包含常规字符和通配符字符。模式匹配过程中，常规字符必须与字符串中指定的字符完全匹配。然而，可使用字符串的任意片段匹配通配符。使用通配符可使LIKE运算符更加灵活。
		通配符一般包括单个字符通配和多个字符通配：
			% 包含零个或更多字符的任意字符串。 WHERE Sname LIKE '%力%' 将查找处于学生名任意位置的包含‘力’字的所有学生名。 
			_(下划线)任何单个字符。 WHERE Sno LIKE '_5' 将查找以5结尾的所有2个字符长度的学生学号(如15、25 等)。 
			通过模式的匹配，如果匹配到指定的模式，LIKE 将返回 TRUE。否则，返回FALSE。

		注意：有时候char类型的字符串长度不匹配的时候，比较时候会自动对照长的字符串在短的字符串尾部加空格

		如果用户要查询的匹配字符串本身就含有%或_，比如要查名字为DB_Design开头的课程的学分，应如何实现呢？这时就要使用ESCAPE ‘ <换码字符>’短语，对通配符进行转义了。 

		例如：	查DB_Design开头课程的课程号和学分。
			SELECT Cno, Ccredit
			FROM Course
			WHERE Cname LIKE ‘DB\_Design%’ ESCAPE ‘\’;
			ESCAPE ‘\’短语表示\为换码字符，这样匹配串中紧跟在\后面的字符”_”不再具有通配符的含义，而是取其本身含义，被转义为普通的“_”字符。

	（4）涉及空值的查询
	因为空值表示缺少数据，所以空值和其它值没有可比性，即不能用等于、不等于、大于或小于和其它数值比较，测试空值只能用比较操作符IS NULL和IS NOT NULL。

	例如： 某些学生选修某门课程后没有参加考试，所以有选课记录，但没有考试成绩，下面来查一下缺少成绩的学生的学号和相应的课程号。
		SELECT Sno, Cno 
		FROM SC
		WHERE Grade IS NULL; 
	
	注意这里的'IS'不能用等号代替。 

	（5）多重条件查询
	逻辑运算符AND和OR可在WHERE子句中把两个或多个条件连接起来。如果这两个运算符同时出现在同一个WHERE条件子句中，则AND的优先级高于OR，但用户可以用括号改变优先级。 

	例如：	查年龄在20岁以下的男同学姓名。
	SELECT Sname 
	FROM Student 
	WHERE Ssex=‘男’AND Sage<20; 

	（6）比较
	例如： 查课程名为数据库的课程的情况。
		SELECT *
		FROM Course
	 	WHERE Cname = '数据库'; 

6. ORDER BY子句
	用户也可以用ORDER BY子句指定按照一个或多个属性列的升序(ASC)或降序(DESC)重新排列查询结果，其中升序ASC为缺省值。如果没有指定查询结果的显示顺序，DBMS将按其最方便的顺序(通常是元组在表中的先后顺序)输出查询结果。

7. 聚集函数
	COUNT([DISTINCT|ALL] *) 统计元组个数； 
	COUNT([DISTINCT|ALL] <列名>) 统计一列中值的个数； 
	SUM([DISTINCT|ALL] <列名>) 计算一列值的总和(此列必须是数值型) ；
	AVG([DISTINCT|ALL] <列名>) 计算一列值的平均值(此列必须是数值型)；
	MAX([DISTINCT|ALL] <列名>) 求一列值中的最大值； 
	MIN([DISTINCT|ALL] <列名>) 求一列值中的最小值。 
	如果指定DISTINCT短语，则表示在计算时要取消指定列中的重复值。如果不指定DISTINCT短语或指定ALL短语(ALL为缺省值)，则表示不取消重复值。

	注意：
		1.聚集函数遇到空值时，除count（*）外，都跳过空值而只处理非空值。
		2.where子句中不能用聚集函数作为条件表达式。
		例：查询选修了3门以上课程的学生学号。

（9）GROUP BY 和 HAVING子句

	GROUP BY子句可以将查询结果表的各行按一列或多列取值相等的原则进行分组，也就是将聚集函数应用到关系中每个由多个分组组成的行上。

	当在用聚集函数的时候，一般都要用到GROUP BY 先进行分组，然后再进行聚集函数的运算。运算完后可能要用到HAVING 子句进行判断，例如判断聚集函数的值是否大于某一个值等等。 


五、 多表查询
1. 链接查询：一次查询涉及到多个表
	连接可以在SELECT 语句的FROM子句或WHERE子句中建立，不同的子句有不同的分类方式，用WHERE子句连接的查询一般分为等值连接查询、非等值连接查询、自然连接查询、外部连接查询和复合条件连接查询；用FROM子句连接的查询一般分为内连接、外连接和交叉连接 
	
	（1）WHERE子句中的连接查询 
		①等值连接和非等值连接
			连接查询的WHERE子句中用来连接两个表的条件称为连接条件或连接谓词，其一般格式为：

				(1)[<表名1>.]<列名1> <比较运算符> [<表名2>.]<列名2> 其中比较运算符主要有：=、>、<、>=、<=、!=、
			
			此外连接谓词还可以使用下面形式：
				(2)[<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>
					select empno,grade from emp,salgrade where emp.sal between salgrade.losal  and salgrade.hisal; 

			连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但不必是相同的。 

			如果是按照两个表中的相同属性进行等值连接，且目标列中去掉了重复的属性列，但保留了所有不重复的属性列，则称之为自然连接。 

		②自身连接
			连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，这种连接称为表的自身连接。

			例如：查询每一门课的间接先修课(即先修课的先修课)
					SELECT FIRST.Cno, SECOND. Cpno 
					FROM Course FIRST, Course SECOND 
					WHERE FIRST. Cpno =SECOND.Cno; 


		③外连接 
			例如：以Student表为主体列出每个学生的基本情况及其选课情况。

			SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade 
    		FROM Student, SC 
    		WHERE Student.Sno=SC.Sno(+); 

    	④复合条件连接
    		上面各个连接查询中，WHERE子句中只有一个条件，即用于连接两个表的谓词。WHERE子句中有多个条件的连接操作，称为复合条件连接

    		例如： 查询选修2号课程且成绩在90分以上的所有学生。
    			SELECT Student.Sno, Sname 
				FROM Student, SC 
				WHERE Student.Sno=SC.Sno AND SC.Cno=2 AND SC.Grade>90; 

内连接(INNER JOIN)使用比较运算符进行表间某(些)列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。根据所使用的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种。

外连接分为左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)和全外连接(FULL OUTER JOIN或FULL JOIN)三种。与内连接不同的是，外连接不只列出与连接条件相匹配的行，而是列出左表(左外连接时)、右表(右外连接时)或两个表(全外连接时)中被舍弃的数据行。

交叉连接(CROSS JOIN)没有ON子句，它返回连接表中所有数据行的笛卡尔积，其结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。

连接操作中的ON (join_condition) 子句指出连接条件，它由被连接表中的列和比较运算符、逻辑运算符等构成。

2. 嵌套查询
	嵌套查询是将其他查询嵌套在另一个查询里面的查询，嵌套在查询中的查询称为子查询。当然，子查询本身也可以是嵌套查询，这样就可以形成更深层次的查询。

	子查询通常出现在WHERE子句中，有时候也出现FROM子句中，有时候也出现在HAVING短语中。
	
	select deptno,avg(sal) avg_sal from emp group by deptno having avg(sal) =(select max(avg(sal)) from emp group by deptno) 查询平均工资最高的部门编号、工资

	子查询的SELECT语句中不能使用ORDER BY子句，ORDER BY子句永远只能对最终查询结果排序。 

3. 集合查询
	SQL提供的这些集合操作包括并操作UNION、交操作INTERSECT和差操作EXCEPT。 

	在Oracle中支持这三种操作，其中EXCEPT用MINUS关键字表示。

	使用UNION将多个查询结果合并起来，形成一个完整的查询结果时，系统会自动去掉重复的元组。需要注意的是，参加UNION操作的各数据项数目必须相同，对应项的数据类型也必须相同。

六、 数据更新
	(1)插入单个元组
	INSERT 
	INTO <表名> [(<属性列1>[,<属性列2>...)] 
	VALUES (<常量1> [,<常量2>]...) 
	如果某些属性列在INTO子句中没有出现，则新记录在这些列上将取空值。但必须注意的是，在表定义时说明了NOT NULL的属性列不能取空值，否则会出错。
	如果INTO子句中没有指明任何列名，则新插入的记录必须在每个属性列上均有值。

	(2)INSERT与子查询相结合
	子查询不仅可以嵌套在SELECT语句中，也可以嵌套在INSERT语句中，把子查询的结果插入到指定的表中，这样的一条INSERT语句，可以一次插入多条元组。

	插入子查询结果的INSERT语句的格式为： 
	INSERT 
	INTO <表名> [(<属性列1> [,<属性列2>...)] 
	(子查询)；

	例如：
		对每门课程，求学生的平均分数，并把结果存入数据库。
		对于这道题，首先要在数据库中建立一个有两个属性列的新表，其中一列存课程号，另一列存放每门课程的平均分数。
     		CREATE TABLE AvgGrade 
      		(Cno NUMBER(4); 
       		AvgGrade NUMBER(3)); 
		然后对数据库的SC表按Cno分组求平均分数，再把课程号和平均分数存入新表中。 
    	INSERT
	    INTO AvgGrade(Cno, AvgGrade) 
	      (SELECT Cno, AVG(Grade) 
	      FROM SC GROUP BY Cno);

	(2)修改数据
		修改操作又称为更新操作，其语句的一般格式为：
		UPDATE <表名> 　 
		SET <列名>=<表达式>[,<列名>=<表达式>]... 
		[WHERE <条件>];
		UPDATE的功能是更新表中的数据。必须提供表名以及SET表达式，即用<表达式>的值取代相应的属性列值，在后面可以加WHERE以限制更新的记录范围。

			1.修改元组
			例如：
				将学号为1001的学生的年龄改为20岁。
				UPDATE Student 
				SET Sage=20 
				WHERE Sno=1001; 

				将所有学生的年龄增加1岁。
				UPDATE Student SET Sage=Sage+1;

			2.UPDATE与子查询的结合 
				带子查询UPDATE语句的格式为： 
					UPDATE <表名>
					SET <列名> = <表达式> ［，<列名> = <表达式>］
					［WHERE<带有子查询的条件表达式>］

					本语句执行时，将修改使<带有子查询的条件表达式>为真的所有元组。

			3.删除数据
				DELETE语句的功能是从指定表中删除满足WHERE子句条件的所有元组。如果省略WHERE子句，表示删除表中全部元组，但表的定义仍在数据字典中。DELETE语句删除的是表中的数据，而不是关于表的定义。DELETE语句的一般格式为：

				DELETE
				FROM <表名>
				[WHERE <条件>]; 

六、视图
	视图是基于一个表或多个表或视图的逻辑表，本身不包含数据，是一个虚表，它在存储时只存储视图的定义，而没有存储对应的数据.
	视图只在刚刚打开的一瞬间，通过定义从基表中搜集数据，并展现给用户。通过视图可以对表里面的数据进行查询和修改。
	视图基于的表称为基表。 
	1.创建视图
		CREATE VIEW命令建立视图，其一般格式为： 
		CREATE VIEW <视图名>[(<列名>[,<列名>]...)] 
		AS <子查询> 
		[WITH CHECK OPTION]; 

		其中子查询可以是任意复杂的SELECT语句，但通常不允许含有ORDER BY子句和DISTINCT短语。 

		WITH CHECK OPTION表示对视图进行UPDATE、INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件(即子查询中的条件表达式)。

		如果CREATE VIEW语句仅指定了视图名，省略了组成视图的各个属性列名，则隐含该视图由子查询中SELECT子句目标列中的诸字段组成。但在下列三种情况下必须明确指定组成视图的所有列名：
		(1)其中某个目标列不是单纯的属性名，而是集函数或列表达式；
		(2)多表连接时选出了几个同名列作为视图的字段；
		(3)需要在视图中为某个列启用新的更合适的名字。

		需要说明的是，组成视图的属性列名必须依照上面的原则，或者全部省略或者全部指定，没有第三种选择。

	2.删除视图
		语句的格式为：
		DROP VIEW <视图名>;

		一个视图被删除后，由此视图导出的其他视图也将失效，用户应该使用DROP VIEW语句将他们一一删除。

		     例3-83删除视图MA_S1。
		DROP VIEW MA_S1;

		执行此语句后，MA_S1视图的定义将从数据字典中删除。由MA_S1视图导出的MA_S2视图的定义虽仍在数据字典中，但该视图已无法使用了，因此应该同时删除

	3.更新视图
		更新视图包括插入(INSERT)、删除(DELETE)和修改(UPDATE)三类操作。由于视图是不实际存储数据的虚表，因此对视图的更新，最终要转换为对基本表的更新。

		为防止用户通过视图对数据进行增删改时，无意或故意操作不属于视图范围内的基本表数据，可在定义视图时加上WITH CHECK OPTION子句，这样在视图上增删改数据时，DBMS会进一步检查视图定义中的条件，若不满足条件，则拒绝执行该操作。

数据流图中处理过程为动词+名词，数据流为名词



















